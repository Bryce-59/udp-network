P0P Design-Test Document
Partner A: Bryce Richardson
Partner B: Tyler Miller
1. Server Design
    Overview
    
        Describe the overall server design. You must include the number of 
        threads you create including the main thread, what each thread is 
        for and doing, any loops you have for each thread (and do this for 
        both event-loop and thread-based server). 

            -

    Justification

        Justify why your design is efficient and show evidence it can 
        handle load efficiently. Specify the number of clients, the file 
        size for each client, and the response rate/delay each client.

            -

    Data structures
    
        List any notable data structures you used and justify the use of
        the data structure. Also specify how you handle synchronization 
        for the data structure if there were any need for synchronization.
    
            - We used a dictionary to contain both sequence numbers and timers
            for each session. There was no need for synchronization in the 
            former. [What about the latter?] These structs allowed a 
            straightforward mapping from the session id to the stored value, 
            and allowed us to quickly learn if a session id was already 
            in-use or not.

    How timeouts are handled
    
        Describe how the timeouts are handled.
    
            - When making an FSA transition that requires a timer to be set, 
            we create a timer thread that, after waiting for 5 seconds, 
            calls a “close_session” function that closes the appropriate 
            session. If we receive a response from this session before the 
            timer expires, we cancel the corresponding timer (before starting
            it back up again after the server sends it response).
    
    How shutdown is handled
    
        Describe how you handled the shutdown gracefully. (That is when you 
        hit 'q' or ctrl+d in the command prompt.)
    
            - A graceful shutdown involves iterating through each session 
            and sending “Goodbye” before calling socket.shutdown() and 
            finally socket.close(). At the current moment, half of this 
            has been fully implemented.

    Any libraries used
    
        List any libraries that you used for the implementation
        and justify the usage.
    
            - socket :  we used the socket library because the 
            server communicates with the clients via socket
            - sys : we used the sys library solely to read 
            input and test whether it was from a tty or not
            - threading : we used the threading library 
            because we used a multiple threads in our server
    
    Corner cases identified
    
        Describe corner cases that you identified and how you handled them.
    
            - There were numerous corner cases that we designed our code 
            to recognize. For example, it was possible for the sequence 
            number to overflow back to zero. To solve this, we allowed 
            our code to respond normally to Data and Goodbye commands 
            with a sequence number of zero. However, it may have been 
            better to recognize when a sequence number was about to 
            overflow and preemptively reset the expected sequence number 
            to zero.

            - Another corner case is when a client accidentally uses a 
            session id that is already in-use. We chose to handle this
            by ignoring any Hello commands that occur after the initial
            hand-shaking for that session id. As a result, the second client
            will time out and be forced to choose a new session id.
    
2. Server Testing
    
    Testing your server
        
        Describe how you tested your server. Include the description 
        of each test case and the setting (such as local only, one 
        local one remote, how many clients, use of mock client, etc.). 
    
            - We tested our server in a few ways:
                - Local/Remote. A lot of the tests on our bare-bones 
                server were done this way. We checked to make sure 
                packets were actually being sent through the socket this way.
                - Remote/Remote where both client and server were on the 
                same UTCS computer. Most of our tests were done this way. 
                We tested our server with various inputs and text files, 
                with one or two clients, in order to seek out bugs. This 
                includes the Dostoyevsky.txt file 
                Remote/Remote where both client and server were on different
                UTCS computers. This was done a few times while we were 
                pair-programming to make sure that it still worked, but we
                quickly realized that it was less efficient than the 
                previously mentioned methods.
    
            - The Dostoyevsky.txt file had 0% loss for both implementations. 
            We have deduced that this is due to our client waiting for each 
            message to be received, which we plan to adjust soon.

3. Client Design
    Overview
    Describe the overall client design. Specify any differences between event-loop based client design and thread-based client design. You must include the number of threads you create including the main thread, what each thread is for and doing, any loops you have for each thread (and do this for both event-loop and thread-based client). 
    Justification
    Justify why your design above is efficient. Also show evidence how your client can handle sending packets from a large file (each line is close to UDP packet max and also contains many lines) and receiving packets from the server at the same time. Note you do not want to cause the false TIMEOUT from server because you are too busy just sending out the packets to the server when the server actually has sent you a packet before the TIMEOUT.
    
    Data structures

        List any notable data structures you used and justify the use of the data structure. 
        Also specify how you handle synchronization for the data structure if there were any need 
        for synchronization.

            - We did not utilize any notable data structures. As of yet, we have not needed a special
            data structure to implement the required functionality.


    How timeouts are handled

        Describe how the timeouts are handled.

            - We start a timer immediately before we begin waiting on the response from the server. If we 
            don't receive a response in 5 seconds, we close the session. Once we receive the response from 
            the server, we cancel the timer before restarting it and repeating the process.


    How shutdown is handled

        Describe how you handled the shutdown gracefully. (That is when you hit 'q' or 
        ctrl+d in the command prompt.)

            - We plan on, upon receiving 'q' or 'eof' from the command prompt, sending GOODBYE to the server
            before terminating the client process.


    Any libraries used
        List any libraries that you used and justify the usage.

            - random : we used random to generate the random 
            session id
            - socket : we used the socket library because the 
            client communicates with the server via socket
            - sys : we used the sys library solely to read 
            input and test whether it was from a tty or not
            - threading : we used the threading library 
            because we used a multiple threads in our client
            (only the thread-based client)

    Corner cases identified
        Describe corner cases that you identified and how you handled them.
        
4. Client Testing
    Testing your client
        Describe how you tested your client. Include the description of
        each test case and the setting (such as local only, one local one
        remote, how many clients, use of mock server, etc.). 

            - We tested the client using Dostoyevsky.txt
                - At UTCS/UTCS (same computer) the loss rate was 93.5%. 
                This is a pretty high amount, so we will spend the week 
                looking for ways to reduce this.
                - Compare this to our barebones server, where the loss rate 
                was 63.4% with the current thread-based client. We will be 
                investigating this difference soon.
            - In all other environments we tested, we found no discrepancies
            in the performance. However, there is a bug that crashes the code
            when it receives certain input, which we will be working to fix.


5. Reflection
Reflection on the process
What was most challenging in implementing the server? What was most challenging testing the server? 

What was most challenging in implementing the client? What was most challenging testing the client? 

What was most fun working on the project? What was most not-so-fun? 

If you are to do this all over again how would you do it differently? 

Reflection on pair programming
Log of the amount of time spent driving and the amount of time spent working individually for each part (e.g., X drives 1 hour; Y drives 45 minutes; X works alone for 1 hour, etc.)
For Part 2
For Part 3
For Part 4
What went well/or not-so-well doing pair programming? What was your take away in this process?


Submission
Remember to export to pdf and push it to your github team repo under the project root (the same level as README.txt)
